---
description: "Follow this guideline when managing state in React components. It promotes grouped, deduplicated, and traceable state through principles like single source of truth, form hook usage, and local/global separation."
globs:
alwaysApply: false
---

# React State Management Guideline

Managing state properly means grouping by meaning, removing duplication, and simplifying data flow.

## üîë Core Principles

### 1. Single Source of Truth
```tsx
// ‚ùå Duplicate state
const [priceMin, setPriceMin] = useState(0);
const [priceMinDisplay, setPriceMinDisplay] = useState("0");

// ‚úÖ Use one source and derive the display value
const [priceRange, setPriceRange] = useState<[number, number]>([0, 5_000_000]);
const priceMinDisplay = useMemo(
  () => formatNumber(priceRange[0].toString()),
  [priceRange]
);
````

### 2. Group Related Fields

```tsx
// ‚ùå Scattered state
const [categoryId, setCategoryId] = useState("");
const [imageSize, setImageSize] = useState(512);
const [bestLimit, setBestLimit] = useState(20);

// ‚úÖ Grouped in a single object
type SearchOption = {
  categoryId: string;
  imageSize: number;
  bestLimit: number;
  price: [number, number];
};

const [options, setOptions] = useState<SearchOption>({
  categoryId: "",
  imageSize: 512,
  bestLimit: 20,
  price: [0, 5_000_000],
});

const updateOption = <K extends keyof SearchOption>(k: K, v: SearchOption[K]) =>
  setOptions((prev) => ({ ...prev, [k]: v }));
```

### 3. Use `useForm` for Form State

```tsx
import { useForm } from "react-hook-form";

type FormValues = {
  categoryId: string;
  imageSize: number;
  bestLimit: number;
  priceMin: string;
  priceMax: string;
};

const { register, handleSubmit, watch, reset } = useForm<FormValues>({
  defaultValues: {
    categoryId: "",
    imageSize: 512,
    bestLimit: 20,
    priceMin: "0",
    priceMax: "5,000,000",
  },
});
```

### 4. Extract Custom Hooks

```tsx
function usePriceRange(initial: [number, number]) {
  const [range, setRange] = useState(initial);
  const reset = () => setRange(initial);
  const setMin = (v: number) => setRange(([_, max]) => [v, max]);
  const setMax = (v: number) => setRange(([min]) => [min, v]);
  return { range, setMin, setMax, reset };
}
```

### 5. Separate Global vs. Local State

**Global (Zustand/Context):**

* Shared across pages: user info, dark mode, preferences

**Local (component state):**

* Modal open/close
* Input values (watch)
* One-time result caches

## ‚úÖ State Checklist

| Check                | Description                                            |
| -------------------- | ------------------------------------------------------ |
| ‚úÖ Single source      | No duplicate useState for same value                   |
| ‚úÖ Grouped fields     | Related fields are grouped into objects/hooks          |
| ‚úÖ Derived values     | Formatting or filtering is computed, not stored        |
| ‚úÖ Global/local split | Only global data lives in store/context                |
| ‚úÖ Form library       | Prefer `react-hook-form` or `formik` over raw useState |

## üö´ Anti-Patterns

1. Duplicating state (real vs. display)
2. Improper sync via `useState(() => {})`
3. Separating related fields into many state hooks
4. Promoting local-only state to global store
5. Writing many similar handler functions

## ‚úÖ Conclusion

State cleanup means **deduplication, separation of concerns, and flow simplification**.
Apply these principles to write shorter, clearer, and more bug-resistant components.

