좋지! 2장은 “검색 → 후보 표준화”에 집중해. **쿠팡 파트너스 Open API**를 호출해 키워드에서 `CandidateItem[]`를 뽑아내고, 우리 표준 타입으로 **정규화 + 중복제거 + 정렬**까지 한 번에 끝내자. (Supabase Edge Functions / Deno 기준)

> 참고: 파트너스 API의 **HMAC 서명 방식과 Authorization 헤더 포맷**은 공식 문서의 예시를 그대로 따를 거야. 메시지는 `signedDate + method + path + query`를 HmacSHA256으로 서명하고, 헤더는
> `CEA algorithm=HmacSHA256, access-key=..., signed-date=..., signature=...` 형식이야. ([Coupang Partner][1])

---

# 디렉토리 구조

```
supabase/
└─ functions/
   ├─ _shared/
   │  ├─ cors.ts          # 1장에서 만든 CORS
   │  ├─ response.ts      # 1장에서 만든 ok/fail
   │  ├─ types.ts         # CandidateItem 등 공통 타입
   │  └─ coupang.ts       # ✅ (신규) 파트너스 HMAC, 호출 유틸
   └─ search/
      └─ index.ts         # ✅ 검색 엔드포인트
```

---

# \_shared/coupang.ts

```ts
// _shared/coupang.ts
// 쿠팡 파트너스 Open API 호출 유틸 (HMAC 서명 + 요청 조립)

import { fail } from "./response.ts";

/** 환경변수 키: Supabase Edge Functions의 .env(.local)에서 주입 */
const ACCESS_KEY = Deno.env.get("COUPANG_ACCESS_KEY") ?? "";
const SECRET_KEY = Deno.env.get("COUPANG_SECRET_KEY") ?? "";

/** 왜
 *  쿠팡 파트너스는 Authorization 헤더에 들어갈 signed-date를 UTC yymmdd'T'HHmmss'Z' 포맷으로 요구한다.
 *  파라미터 없음, 반환값은 헤더에 바로 넣을 문자열.
 */
export function utcSignedDate(): string {
  // 예: 250810T03:12:45Z  (UTC 기준)
  const d = new Date();
  const utc = new Date(d.getTime() + d.getTimezoneOffset() * 60000);
  const pad = (n: number) => n.toString().padStart(2, "0");
  const yy = utc.getUTCFullYear().toString().slice(-2);
  const MM = pad(utc.getUTCMonth() + 1);
  const dd = pad(utc.getUTCDate());
  const HH = pad(utc.getUTCHours());
  const mm = pad(utc.getUTCMinutes());
  const ss = pad(utc.getUTCSeconds());
  return `${yy}${MM}${dd}T${HH}${mm}${ss}Z`;
}

/** 왜
 *  문서 규칙: message = signedDate + method + path + query
 *  query는 '?' 없이 원시 쿼리스트링 그대로. (문서 예시 준수)
 * 파라미터
 *  - method: "GET" | "POST" ...
 *  - path:   "/v2/providers/affiliate_open_api/apis/openapi/products/search" (도메인 제외)
 *  - query:  "keyword=무선+청소기&limit=30" (없으면 빈 문자열)
 * 리턴
 *  - Authorization 헤더 값 (CEA ...)
 */
export async function createAuthorization(
  method: string,
  path: string,
  query: string,
  signedDate?: string,
): Promise<string> {
  if (!ACCESS_KEY || !SECRET_KEY) {
    throw new Error("COUPANG keys are not configured");
  }
  const dt = signedDate ?? utcSignedDate();
  const message = `${dt}${method}${path}${query ?? ""}`;

  const algo = "HmacSHA256";
  const key = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(SECRET_KEY),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"],
  );
  const sigBytes = await crypto.subtle.sign(
    "HMAC",
    key,
    new TextEncoder().encode(message),
  );
  const signature = [...new Uint8Array(sigBytes)]
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");

  return `CEA algorithm=${algo},access-key=${ACCESS_KEY},signed-date=${dt},signature=${signature}`;
}

/** 왜
 *  쿼리스트링을 "빌드한 그대로" 서명과 실제 요청에 동일 적용하려고 별도 함수로 고정한다.
 * 파라미터
 *  - params: 레코드 형태의 키/값. undefined/null은 제외.
 * 동작
 *  - URLSearchParams에 순서대로 넣어 encode한다. (우리가 만든 순서를 서명·요청 둘 다에 재사용)
 */
export function buildQueryString(params: Record<string, string | number | boolean | undefined | null>): string {
  const sp = new URLSearchParams();
  for (const [k, v] of Object.entries(params)) {
    if (v === undefined || v === null || v === "") continue;
    sp.append(k, String(v));
  }
  // URLSearchParams는 삽입 순서를 보존한다. 이 순서를 기준으로 서명/요청을 동일화.
  return sp.toString(); // 예: "keyword=%EB%AC%B4%EC%84%A0&limit=30"
}

/** 왜
 *  실제 GET 호출을 공통화. (베이스/패스/쿼리 → Authorization 생성 → fetch)
 * 파라미터
 *  - base: "https://api-gateway.coupang.com"
 *  - path: "/v2/providers/affiliate_open_api/apis/openapi/products/search"
 *  - query: "keyword=...&limit=..."
 * 리턴
 *  - fetch Response(JSON은 호출부에서 파싱)
 */
export async function signedGet(base: string, path: string, query: string): Promise<Response> {
  if (!ACCESS_KEY || !SECRET_KEY) {
    return fail("COUPANG_API_KEY_MISSING", "UNAUTHORIZED", 401) as unknown as Response;
  }
  const auth = await createAuthorization("GET", path, query);
  const url = `${base}${path}?${query}`;
  return fetch(url, {
    method: "GET",
    headers: {
      "Authorization": auth,
      "Content-Type": "application/json",
    },
  });
}
```

### 함수별 설명 요약

* **`utcSignedDate()`**

  * *왜* : 문서 포맷 강제.
  * *파라미터* : 없음.
  * *리턴* : `yyMMdd'T'HHmmss'Z'`(UTC).
  * *함정* : 로컬시간으로 찍으면 서명 불일치.

* **`createAuthorization(method, path, query, signedDate?)`**

  * *왜* : Authorization 헤더 문자열 생성.
  * *파라미터* : HTTP 메서드/패스/쿼리(’?’ 없이 원문), 테스트 시 `signedDate` 고정 가능.
  * *동작* : `dt+method+path+query`를 HMAC-SHA256 → hex 인코딩 → CEA 포맷 조립. (공식 예시 준수) ([Coupang Partner][1])
  * *리턴* : `CEA algorithm=...,access-key=...,signed-date=...,signature=...`
  * *자주 하는 실수* : `path`에 도메인까지 넣음 / `query` 앞에 `?`를 붙임 / 로컬타임 사용.

* **`buildQueryString(params)`**

  * *왜* : **서명용 쿼리**와 **실제 요청 쿼리**를 동일하게 유지.
  * *함정* : `encodeURIComponent` 수동 혼용으로 서명-요청 불일치가 생김 → 항상 이 함수로 생성.

* **`signedGet(base, path, query)`**

  * *왜* : 헤더/서명/GET 호출 보일러플레이트 제거.
  * *리턴* : `fetch Response` (실패 시도 포함, JSON 파싱은 호출부 책임)
  * *운영팁* : 429가 올 수 있으니 호출부에서 백오프 로직 권장.

---

# functions/search/index.ts

```ts
// functions/search/index.ts
// 키워드 → Coupang Partners 검색 → CandidateItem[] 정규화 + 중복제거 + 정렬

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { corsHeaders } from "../_shared/cors.ts";
import { ok, fail } from "../_shared/response.ts";
import type { CandidateItem } from "../_shared/types.ts";
import { buildQueryString, signedGet } from "../_shared/coupang.ts";

/** 계약: 입력 타입 */
type SearchInput = {
  keyword: string;
  categoryId?: string;  // (선택) 파트너스 검색에 바로 반영 안 되면 후처리 필터
  priceMin?: number;    // (선택) 일부 파라미터 미지원 시 로컬 필터
  priceMax?: number;    // (선택)
  limit?: number;       // 기본 30
};

/** 계약: 출력 타입 */
type SearchOutput = {
  candidates: CandidateItem[];
  rawCount: number;     // API 원본 개수
  dedupedCount: number; // 중복 제거 후 개수
};

const API_BASE = "https://api-gateway.coupang.com";
// 참고: 파트너스 제품 검색 경로(변경될 수 있음. 운영 시 문서 확인)
const PRODUCTS_SEARCH_PATH = "/v2/providers/affiliate_open_api/apis/openapi/products/search";

serve(async (req) => {
  // CORS 프리플라이트
  if (req.method === "OPTIONS") return new Response(null, { headers: corsHeaders });

  if (req.method !== "POST") {
    return fail("METHOD_NOT_ALLOWED", "METHOD_NOT_ALLOWED", 405);
  }

  try {
    const body = (await req.json()) as SearchInput;

    // 1) 입력 검증
    const keyword = (body.keyword ?? "").trim();
    if (!keyword) return fail("keyword is required", "BAD_REQUEST", 400);
    const limit = Math.min(Math.max(body.limit ?? 30, 1), 50); // 1..50 권장

    // 2) 쿼리 스트링 구성 (서명/요청에 동일 적용)
    const query = buildQueryString({
      keyword, // URLSearchParams가 안전하게 인코딩
      limit,
      // 필요시 추가 파라미터: subId, imageSize, etc. (문서 확인)
    });

    // 3) 서명 + 호출
    const res = await signedGet(API_BASE, PRODUCTS_SEARCH_PATH, query);

    // 4) HTTP 레벨 에러 처리
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      // 401/403: 키 문제, 429: 레이트리밋, 5xx: 서버
      return fail(`COUPANG_API_ERROR(${res.status})`, "UPSTREAM_ERROR", res.status, { text });
    }

    // 5) 본문 파싱
    const json = await res.json().catch(() => null) as any;
    if (!json) return fail("INVALID_JSON", "UPSTREAM_ERROR", 502);

    // 6) 결과 배열 추출 (파트너스 응답 스키마는 문서/환경에 따라 다를 수 있어 유연 파싱)
    const items: any[] =
      json?.data?.productData?.content ??
      json?.data?.products ??
      json?.products ??
      json?.content ??
      [];

    // 7) 정규화 → CandidateItem[]
    const normalized: CandidateItem[] = items.map(normalizePartnerItem).filter(Boolean) as CandidateItem[];

    // 8) 로컬 필터 (categoryId / price 범위 등)
    const filtered = normalized.filter((it) => {
      const inMin = body.priceMin != null ? (it.priceKRW ?? Infinity) >= body.priceMin : true;
      const inMax = body.priceMax != null ? (it.priceKRW ?? -Infinity) <= body.priceMax : true;
      // categoryId는 API 직지원이 아닐 수 있어 후처리(경로에 포함되면 통과)
      const inCat = body.categoryId ? (it.categoryPath ?? []).some(c => c.includes(body.categoryId!)) : true;
      return inMin && inMax && inCat;
    });

    // 9) 중복제거 (id > url > title 우선 키)
    const deduped = dedupeCandidates(filtered);

    // 10) 정렬 (가격 오름차순 → 로켓 우선)
    deduped.sort((a, b) => {
      const pa = a.priceKRW ?? Number.POSITIVE_INFINITY;
      const pb = b.priceKRW ?? Number.POSITIVE_INFINITY;
      if (pa !== pb) return pa - pb;
      // 가격 동일 시 로켓 true 먼저
      const ra = a.isRocket ? 0 : 1;
      const rb = b.isRocket ? 0 : 1;
      return ra - rb;
    });

    return ok<SearchOutput>({
      candidates: deduped,
      rawCount: items.length,
      dedupedCount: deduped.length,
    }, { headers: corsHeaders });

  } catch (err) {
    console.error(err);
    return fail("UNEXPECTED_ERROR", "UNEXPECTED_ERROR", 500);
  }
});

/** 왜
 *  파트너스 응답 스키마가 배포/계정에 따라 다를 수 있으므로 다중 키를 안전하게 매핑.
 * 파라미터
 *  - it: any (원본 아이템)
 * 리턴
 *  - CandidateItem (불완전 시 일부 필드 null/undefined 허용)
 */
function normalizePartnerItem(it: any): CandidateItem | null {
  if (!it) return null;

  // 가능한 키 후보들 (운영 시 실제 응답 키로 확정해 좁혀 나가면 됨)
  const id =
    it.productId ?? it.itemId ?? it.id ?? it.product?.id ??
    hashFallback(it.productUrl ?? it.url ?? it.outboundLink ?? JSON.stringify(it));

  const url =
    it.productUrl ?? it.url ?? it.outboundLink ?? null;

  const title =
    it.productName ?? it.title ?? it.name ?? "";

  const image =
    it.imageUrl ?? it.productImage ?? it.image ?? null;

  const priceKRW =
    num(it.productPrice) ?? num(it.price) ?? num(it.pcPrice) ?? null;

  // 로켓 여부 추정 키들
  const isRocket =
    it.isRocket ?? it.rocket ?? it.isRocketWow ?? false;

  // 카테고리 경로
  const categoryPath: string[] | undefined =
    it.categoryPath ?? it.categories ?? (it.categoryName ? [it.categoryName] : undefined);

  return {
    id: String(id),
    url: url ?? "",
    title: String(title),
    priceKRW,
    isRocket: Boolean(isRocket),
    image: image ?? null,
    categoryPath,
  };
}

/** 숫자 파싱 보조 */
function num(x: unknown): number | null {
  if (x == null) return null;
  const n = typeof x === "string" ? Number(x.replace(/[^\d.]/g, "")) : Number(x);
  return Number.isFinite(n) ? n : null;
}

/** 충돌 방지를 위한 간단 해시(임시용) */
function hashFallback(s: string): string {
  let h = 0;
  for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
  return `h${h.toString(16)}`;
}

/** 중복 제거: id → url → title 순서로 키 사용 */
function dedupeCandidates(arr: CandidateItem[]): CandidateItem[] {
  const seen = new Set<string>();
  const out: CandidateItem[] = [];
  for (const it of arr) {
    const key = it.id || it.url || it.title;
    if (!key) continue;
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(it);
  }
  return out;
}
```

---

## 핵심 함수/파라미터 설명 (왜/파라미터/동작/리턴/운영 팁/실수)

### `SearchInput` (요청 바디)

* **왜**: 프론트가 보낼 수 있는 검색 조건의 계약.
* **필드**

  * `keyword` *(필수)*: 검색어.
  * `categoryId?` *(선택)*: API가 직접 지원하지 않으면 로컬 필터로 처리.
  * `priceMin?`, `priceMax?` *(선택)*: 원본 API 지원이 애매할 때 로컬 필터.
  * `limit?` *(선택)*: 기본 30, 1\~50로 클램프.
* **실수**: 공백 keyword 허용 → 에러로 반환.

### `PRODUCTS_SEARCH_PATH`

* **왜**: 도메인을 제외한 **정확한 path**를 분리해두면, **서명 문자열** 생성 시 실수를 줄임.
* **주의**: 서명은 `path + query`를 그대로 사용해야 한다. 바꾸면 401/403. (서명 규칙은 공식 문서 예시와 동일) ([Coupang Partner][1])

### `buildQueryString(params)`

* **왜**: 서명/요청 쿼리를 **동일한 방식으로** 만들기 위해.
* **파라미터**: 객체(불필요값은 제외).
* **운영 팁**: 쿼리 파라미터 추가(예: `subId`)가 생기면 **여기만** 수정.

### `signedGet(base, path, query)`

* **왜**: Authorization 생성/헤더 병합/실제 fetch까지 공통화.
* **파라미터**: `base`, `path`, `query` 모두 문자열. `query`에는 `?` 없이.
* **리턴**: 생 Response (호출부에서 `res.ok` 확인).
* **실수**: `query` 앞에 `?` 포함 → 서명/요청 불일치.

### `normalizePartnerItem(it)`

* **왜**: 공급자 응답 스키마가 바뀌어도 **우리 표준**(`CandidateItem`)은 고정.
* **동작**: 여러 후보 키 중 먼저 발견되는 값으로 매핑.
* **운영 팁**: 실제 계정 응답 구조가 확정되면 **키 후보를 줄이고** fast-path로 간결화.

### `dedupeCandidates(arr)`

* **왜**: 키워드 중복 호출/랭킹 중복을 제거.
* **전략**: `id → url → title` 우선순위 키로 Set 검사.

---

## 흔한 함정 (진짜 많이 겪는 포인트)

1. **서명 불일치**

* `signed-date`는 **UTC, yyMMdd'T'HHmmss'Z'**. 로컬시간 쓰면 실패. ([Coupang Partner][1])
* message 조립 순서/내용은 **문서 예시 그대로**: `signedDate + method + path + query` (query 앞에 `?` 없음). ([Coupang Partner][1])

2. **쿼리 인코딩**

* 수동 `encodeURIComponent`와 `URLSearchParams`를 섞으면 **서명과 실제 요청이 달라짐**. → `buildQueryString`만 사용.

3. **필드 매핑 착각**

* 응답 키가 배포/계정/버전별로 약간씩 다를 수 있다. → **정규화 레이어에서 흡수**.

4. **레이트 리밋/429**

* 짧은 간격 연속 호출 시 429 가능. → **지수 백오프**(예: 400ms, 800ms, 1600ms … 최대 5회) 권장.

---

## 미니 과제 (2장)

* 같은 `keyword`로 `limit=30`을 **3번 연속 호출**한 뒤:

  1. 결과를 합쳐 `dedupeCandidates`로 **중복 제거**
  2. `priceKRW` 기준 **오름차순 정렬**
  3. 콘솔에 `rawCount` vs `dedupedCount`를 출력
* 보너스: `isRocket=true`를 **상단 고정**하는 정렬 2차 키 적용(샘플 코드 포함됨).

---

## 다음 액션

* 실제 계정 응답 스키마를 확인해 `normalizePartnerItem()`의 키 후보를 **실제 키로 고정**하자.
* 원하면 2.5장 느낌으로 **입력 검증 스키마(Zod)**, **429 백오프 유틸**까지 붙여줄게.
* 준비되면 3장(선택 레이어)로 넘어가서 **프로젝트/선택 상태 DB 스키마 + idempotent 저장**을 설계하자.

[1]: https://partner-developers.coupangcorp.com/hc/en-us/articles/360053719371-Create-HMAC-Signature "Create HMAC Signature – Coupang Partner Integration"
