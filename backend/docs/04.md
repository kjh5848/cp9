좋아. **5장: 작성 레이어 (GPT: ResearchPack → SeoDraft)** 바로 넣자.
전제: 4장에서 `research` 테이블에 아이템별 `ResearchPack`이 저장되어 있음. 이번 함수는 그걸 읽어 **메타 + 마크다운 초안**을 만들어 `drafts` 테이블에 저장해.

---

# 5장. 작성 레이어

## 목적(왜)

* 구조화된 조사 결과(ResearchPack)를 \*\*사람이 읽는 글(SeoDraft)\*\*로 일관되게 생성하고, 톤/형식을 한 곳에서 관리하기 위해.

## 계약(입/출)

* **POST `/write`**

  * 입력:

    ```json
    {
      "projectId": "uuid",
      "itemIds": ["i-001","i-002"],     // 생략 시 프로젝트 내 전체
      "promptVersion": "v1",            // 선택
      "force": false                    // true면 기존 초안 덮어씀
    }
    ```
  * 출력: `{ success: true, data: { written: number, failed: string[] } }`

## 배울 것

* **할루시네이션 억제 프롬프트**(“리서치에 없는 사실 금지”),
* **길이/포맷 가드**(메타블록 + 마크다운 섹션),
* **저장 멱등성(upsert)**

## 흔한 함정

* 모델이 코드펜스/설명 텍스트를 섞음 → **JSON만 파싱**하도록 클린업
* 과최적화(키워드 남발) → **간단 룰 후처리**로 반복어 정리
* 없는 필드 생성(가격/스펙 추정) → 프롬프트에 **금지**를 못 박기

## 미니 과제

* `force=false`로 1회 생성 후, 같은 요청을 다시 보내면 **written=0**이 되도록 캐시 확인.
* `force=true`로 다시 보내서 **업데이트**되는지 확인.

---

## 테이블 스키마 (1회 실행)

```sql
create table if not exists drafts (
  project_id uuid,
  item_id text,
  meta jsonb not null,          -- { title, description, slug, tags? }
  markdown text not null,
  version text default 'v1',
  updated_at timestamptz default now(),
  primary key (project_id, item_id)
);
```

---

## Edge Function: `supabase/functions/write/index.ts` (단일 파일, 바로 실행)

````ts
// @ts-ignore
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
// @ts-ignore
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

/** ----- 타입 ----- */
type ResearchPack = {
  itemId: string;
  title?: string;
  priceKRW?: number | null;
  isRocket?: boolean | null;
  features?: string[];
  pros?: string[];
  cons?: string[];
  keywords?: string[];
  metaTitle?: string;
  metaDescription?: string;
  slug?: string;
};

type SeoDraft = {
  itemId: string;
  meta: { title: string; description: string; slug: string; tags?: string[] };
  markdown: string;
};

type ReqBody = {
  projectId: string;
  itemIds?: string[];
  promptVersion?: string;
  force?: boolean;
  maxWords?: number;           // 선택: 본문 길이 제한(대략)
};

/** ----- 공통 응답/헤더 ----- */
const CORS = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "POST,OPTIONS",
  "Access-Control-Allow-Headers": "content-type, authorization, apikey",
  "Access-Control-Max-Age": "86400",
  "content-type": "application/json; charset=utf-8",
} as const;

const json = (body: unknown, status = 200) =>
  new Response(JSON.stringify(body), { status, headers: CORS });

/** ----- ENV & Supabase ----- */
const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const OPENAI_API_KEY = Deno.env.get("OPENAI_API_KEY")!;

const sb = createClient(SUPABASE_URL, SERVICE_ROLE, { auth: { persistSession: false } });

/** ----- 서버 진입 ----- */
serve(async (req) => {
  if (req.method === "OPTIONS") return json(null, 204);
  if (req.method !== "POST") return json({ success: false, error: "METHOD_NOT_ALLOWED" }, 405);

  try {
    const body = await safeJson<ReqBody>(req);
    if (!body?.projectId) return json({ success: false, error: "PROJECT_ID_REQUIRED" }, 400);

    const projectId = body.projectId.trim();
    const promptVersion = body.promptVersion || "v1";
    const force = !!body.force;
    const maxWords = clamp(body.maxWords ?? 1100, 400, 2000); // 글 길이 가드(대략)

    // 1) ResearchPack 로드 (필요한 아이템만)
    const itemFilter = Array.isArray(body.itemIds) && body.itemIds.length > 0
      ? body.itemIds
      : null;

    let q = sb.from("research").select("item_id, pack").eq("project_id", projectId);
    if (itemFilter) q = q.in("item_id", itemFilter);

    const { data: packsRows, error: packsErr } = await q;
    if (packsErr) {
      console.error(packsErr);
      return json({ success: false, error: "DB_ERROR", detail: packsErr.message }, 500);
    }
    const packs: ResearchPack[] = (packsRows ?? []).map((r: any) => ({
      ...(r.pack || {}),
      itemId: r.item_id,
    }));
    if (packs.length === 0) return json({ success: false, error: "NO_RESEARCH_PACKS" }, 400);

    // 2) 이미 초안이 있는지 확인 (force=false면 스킵)
    const existingMap = new Map<string, true>();
    if (!force) {
      let dq = sb.from("drafts").select("item_id").eq("project_id", projectId);
      if (itemFilter) dq = dq.in("item_id", itemFilter);
      const { data: drafted } = await dq;
      (drafted ?? []).forEach((d: any) => existingMap.set(d.item_id, true));
    }

    // 3) 생성 루프
    const failed: string[] = [];
    let written = 0;

    for (const pack of packs) {
      if (!force && existingMap.has(pack.itemId)) continue;

      try {
        const draft = await makeDraft(pack, promptVersion, maxWords);

        // 과최적화 간단 후처리 (반복어 정리)
        draft.markdown = deRepeatKeywords(draft.markdown, pack.keywords ?? [], 0.06);

        // 저장 (upsert)
        const { error: upErr } = await sb
          .from("drafts")
          .upsert({
            project_id: projectId,
            item_id: pack.itemId,
            meta: draft.meta,
            markdown: draft.markdown,
            version: promptVersion,
            updated_at: new Date().toISOString(),
          }, { onConflict: "project_id,item_id" });

        if (upErr) throw upErr;
        written++;

      } catch (e) {
        console.error("write failed:", pack.itemId, e);
        failed.push(pack.itemId);
      }
    }

    return json({ success: true, data: { written, failed } });

  } catch (e) {
    console.error(e);
    return json({ success: false, error: "UNEXPECTED_ERROR" }, 500);
  }
});

/** ----- Draft 생성 (OpenAI Chat Completions) ----- */
async function makeDraft(pack: ResearchPack, v: string, maxWords: number): Promise<SeoDraft> {
  // 시스템/유저 메시지 구성
  const sys = [
    "당신은 SEO 카피라이터입니다.",
    "사용자에게는 ResearchPack으로 제공된 사실만 사용하세요.",
    "추정/창작/가격 임의 변경 금지. 없는 정보는 비워두거나 언급하지 마세요.",
    "출력은 반드시 JSON 하나만. 코드펜스/설명문 없이.",
  ].join(" ");

  const user = buildUserPrompt(pack, v, maxWords);

  // Chat Completions 호출 (gpt-4o-mini 예시)
  const resp = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${OPENAI_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: sys },
        { role: "user", content: user },
      ],
      temperature: 0.4,
      max_tokens: 1400,
    }),
  });

  if (!resp.ok) {
    const t = await resp.text().catch(() => "");
    throw new Error(`OpenAI ${resp.status}: ${t}`);
  }

  const json = await resp.json();
  const text: string = json?.choices?.[0]?.message?.content ?? "";
  const out = strictJson(text);

  // 안전 보강 & 기본값
  const meta = {
    title: String(out?.meta?.title ?? pack.metaTitle ?? pack.title ?? pack.itemId).slice(0, 80),
    description: String(out?.meta?.description ?? pack.metaDescription ?? "").slice(0, 160),
    slug: slugify(String(out?.meta?.slug ?? pack.slug ?? pack.title ?? pack.itemId)),
    tags: Array.isArray(out?.meta?.tags) ? out.meta.tags.slice(0, 8) : [],
  };

  let markdown = String(out?.markdown ?? "").trim();
  if (!markdown) {
    markdown = fallbackMarkdown(pack, meta);
  }

  return { itemId: pack.itemId, meta, markdown };
}

/** ----- 프롬프트 빌더 ----- */
function buildUserPrompt(pack: ResearchPack, v: string, maxWords: number) {
  // 섹션 가이드: H1=1, H2/H3 적정, 체크리스트/FAQ 포함
  return [
    `다음 ResearchPack을 기반으로 한국어 SEO 초안을 생성하세요.`,
    `리서치 데이터만 사용하고, 없는 사실은 적지 마세요.`,
    `최대 약 ${maxWords} 단어로, 간결하고 스캐너블하게.`,
    `메타블록 + 마크다운을 아래 JSON 스키마로 출력하세요.`,
    ``,
    `ResearchPack: ${JSON.stringify(pack)}`,
    ``,
    `출력 스키마(반드시 이 JSON 그대로):`,
    `{
      "meta": { "title": string, "description": string, "slug": string, "tags": string[] },
      "markdown": string
    }`,
    ``,
    `마크다운 규칙:`,
    `- H1은 1개: "# {제목}"`,
    `- H2/H3로 섹션 구성 (특징, 장단점, 추천 대상, 사용 팁, FAQ 등)`,
    `- 불릿/체크리스트 적극 활용`,
    `- 과도한 키워드 반복 금지 (자연스럽게)`,
    `- 가격/스펙은 리서치 값이 있을 때만`,
    ``,
    `prompt_version: ${v}`,
  ].join("\n");
}

/** ----- 유틸 ----- */
function slugify(s: string) {
  return (s || "")
    .toLowerCase()
    .normalize("NFKD")
    .replace(/[^\w\s-]/g, "")
    .trim()
    .replace(/\s+/g, "-")
    .slice(0, 80) || "item";
}

function strictJson(s: string): any {
  const cleaned = s
    .replace(/^\s*```json\s*/i, "")
    .replace(/^\s*```\s*/i, "")
    .replace(/\s*```$/i, "")
    .trim();
  try { return JSON.parse(cleaned); } catch { return {}; }
}

function fallbackMarkdown(p: ResearchPack, meta: SeoDraft["meta"]): string {
  const f = (arr?: string[]) => (arr && arr.length ? arr.map(x => `- ${x}`).join("\n") : "- (정보 없음)");
  return [
    `# ${meta.title}`,
    ``,
    meta.description ? `> ${meta.description}\n` : "",
    p.priceKRW != null ? `- 예상 가격: ${p.priceKRW.toLocaleString()}원` : "",
    p.isRocket != null ? `- 로켓배송: ${p.isRocket ? "가능" : "불가"}` : "",
    ``,
    `## 주요 특징`,
    f(p.features),
    ``,
    `## 장점`,
    f(p.pros),
    ``,
    `## 단점`,
    f(p.cons),
    ``,
    `## 이런 분께 추천`,
    p.keywords?.length ? `- ${p.keywords.join(", ")}` : "- (정보 없음)",
  ].filter(Boolean).join("\n");
}

function deRepeatKeywords(text: string, kws: string[], maxRatio = 0.06): string {
  if (!kws || kws.length === 0) return text;
  const total = Math.max(text.split(/\s+/).length, 1);
  for (const kw of kws) {
    const re = new RegExp(escapeRegExp(kw), "gi");
    const matches = text.match(re)?.length ?? 0;
    if (matches / total > maxRatio) {
      // 과도하면 일부를 제거(순차적으로 1/3만 남김)
      let kept = 0, target = Math.ceil((total * maxRatio) / Math.max(kw.split(/\s+/).length,1));
      text = text.replace(re, () => (++kept <= target ? kw : ""));
    }
  }
  return text.replace(/\n{3,}/g, "\n\n").replace(/[ \t]{2,}/g, " ");
}

function escapeRegExp(s: string) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

async function safeJson<T>(req: Request): Promise<T | null> {
  const ct = req.headers.get("content-type") || "";
  if (!ct.includes("application/json")) return null;
  try {
    const txt = await req.text();
    if (!txt) return null;
    return JSON.parse(txt) as T;
  } catch { return null; }
}

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}
````

---

## Postman 예시

* **POST** `http://localhost:54321/functions/v1/write`
* **Headers**: `Content-Type: application/json`
* **Body (projectId 전체 생성)**:

```json
{
  "projectId": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
  "promptVersion": "v1",
  "force": false
}
```

* **특정 아이템만**:

```json
{
  "projectId": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
  "itemIds": ["i-001","i-002"],
  "maxWords": 900
}
```

---

## 왜 이 방식이 안전한가?

* **OpenAI Chat Completions 표준 사용**(안정적이고 오래 지원됨). ([OpenAI 플랫폼][1])
* 경량 모델 예시로 `gpt-4o-mini` 사용(속도/비용 균형). ([OpenAI 플랫폼][2])
* **JSON-only 출력**을 강제하고 코드펜스 제거 파서로 안정 파싱.
* 초안 저장은 **upsert**로 멱등성 보장.

---

원하면 이어서 \*\*6장(검수 레이어)\*\*에서 `approve / re-research / rewrite_ai / rewrite_user` 분기와 **부분 재실행**까지 붙여줄게.

[1]: https://platform.openai.com/docs/api-reference/introduction?utm_source=chatgpt.com "API Reference"
[2]: https://platform.openai.com/docs/models/gpt-4o-mini?utm_source=chatgpt.com "Model - OpenAI API"
